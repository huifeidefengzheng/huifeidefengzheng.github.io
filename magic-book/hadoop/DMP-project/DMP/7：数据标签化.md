---
typora-root-url: image
---

[TOC]



## 2.15：数据标签化

前面的操作都算是对数据得到一种ETL操作，转化各种纬度指标，生成商圈库等；

那么，作为广告推荐，广告主在页面上筛选受众目标人群的时候，这些筛选元素其实就是数据标签化的另一种显示；

![image-20181101130303847](image-20181101130303847.png)



因此，我们需要将每一个人重要指标进行标签化，然后存储到kudu

### 2.15.1：业务流程

![image-20181101135754183](image-20181101135754183.png)



### 2.15.2：编写抽取标签的公共逻辑

实际生产中，标签数量是非常庞大的，为了让代码在阅读的时候非常的简化明了，应该一个object中抽取一个标签

因此，我们需要提前指定好一个标签特质，专门抽取标签

```scala
package `trait`

trait MakeTag {
  /**
    * 生成标签，后续不同标签有不同逻辑
    * @param args
    * @return
    */
  def make(args:Any*):Map[String,Double]
}
```

### 2.15.4：APP类添加代码逻辑

```scala
  //TODO 数据标签化
  TagProcess.process(spark,context)
```

### 2.15.5：开发TagProcess

TagProcess主要提供如下功能：

1：提前过滤掉不符合规则的数据集

2：生成当天标签数据集

3：统一用户识别

4：标签聚合

5：获取历史标签数据集，调用TAGS_Attenuation.Merge

#### 2.15.5.1：提前过滤掉不符合规则的数据集

```scala
import spark.implicits._
    import org.apache.kudu.spark.kudu._
    val odsDF = spark.read.options(options).kudu
    //读取商圈信息
    spark.read.options(areaOptions).kudu.createOrReplaceTempView("t_business_area")
    //2、过滤不符合规范的数据，去重
    //select * from ods where (imei is not null and imei!='') or (mac is not null and mac!='') or
    val filterDF = odsDF.filter(
      """
        |(imei is not null and imei!='') or
        |(mac is not null and mac!='') or
        |(idfa is not null and idfa!='') or
        |(openudid is not null and openudid!='') or
        |(androidid is not null and androidid!='')
      """.stripMargin)

    filterDF.createOrReplaceTempView("t_ods")
```

#### 2.15.5.2：生成当天标签数据集

需要抽取的标签：

| 标签名称       |
| -------------- |
| 广告位类型     |
| APP名称        |
| 渠道           |
| 设备           |
| 关键词         |
| 地域标签       |
| 性别标签       |
| 年龄标签       |
| 用户所有识别码 |
| 商圈标签       |



##### 2.15.5.2.1：加载需要的字典brodcast，作为小表处理

| 字典名称               | 内容示例                                                     |
| ---------------------- | ------------------------------------------------------------ |
| APPID-APPNAME字典      | XRX100003##YY直播                                            |
| sensitiveDic敏感词词典 | 出售雷管 炸药                                                |
| devicedic设备相关字典  | 1##D00010001 2##D00010002 3##D00010003 4##D00010004 WIFI##D00020001 4G##D00020002 3G##D00020003 2G##D00020004 NETWORKOTHER##D00020005 移动##D00030001 联通##D00030002 电信##D00030003 OPERATOROTHER##D00030004 |

```scala
 //3、app字典文件广播
    /**
      * 将商圈信息补充到ods中
      */
    spark.udf.register("getGeoHashCode",getGeoHashCode _)

    spark.sql("cache table t_business_area")
    val odsAreaDF = spark.sql(
              """
              select a.*,b.areas
               from t_ods a left join t_business_area b
               on getGeoHashCode(a.longitude,a.latitude) = b.genhash
                """.stripMargin)
    //看执行计划
    //odsAreaDF.explain()

    val appIDName = spark.read.textFile(ConfigUtils.APPID_NAME)
    //将字典文件数据收集到driver端，用于广播
    val appIdNameCollect: Array[(String, String)] = appIDName.map(line => {
      val arr = line.split("##")
      (arr(0), arr(1))
    }).collect()
    val appBc = spark.sparkContext.broadcast(appIdNameCollect.toMap)
    //4、设备字典文件广播
    val device = spark.read.textFile(ConfigUtils.DEVICE_DIC)
    //将字典文件数据收集到driver端，用于广播
    val deviceCollect = device.map(line => {
      val arr = line.split("##")
      (arr(0), arr(1))
    }).collect()
    val deviceBc:Broadcast[Map[String, String]] =  spark.sparkContext.broadcast(deviceCollect.toMap)

```

##### 2.15.5.2.2：抽取标签

###### 2.15.5.2.2.1：抽取标总代吗

```scala
//5、遍历数据生成用户标签
    val currentDayRdd: RDD[(String, (List[String], Map[String, Double]))] = odsAreaDF.rdd.persist().map(row => {
      //1、生成app标签
      val appTag: Map[String, Double] = AppTag.make(row, appBc)

      //2、设备标签
      val deviceTag: Map[String, Double] = DeviceTag.make(row, deviceBc)

      //3、地域标签
      val reionTag = RegionTag.make(row)

      //4、广告位类型
      val adTypeTag = AdTypeTag.make(row)

      //5、关键字
      val keywordTags = KeywordTag.make(row)

      //6、渠道标签
      val channelTag = ChannelTag.make(row)

      //7、年龄标签
      val ageTag = AgeTag.make(row)

      //8、性别标签
      val sexTag = SexTag.make(row)

      //9、商圈标签
      val areaTag = BusinessAreaTag.make(row)
      //10、用户所有标识
      val userIds = getAllUserIds(row)
      //用户唯一标识
      val userId = userIds.head
      //用户所有标签
      val tags = appTag ++ deviceTag ++ reionTag ++ adTypeTag ++ keywordTags ++ channelTag ++ ageTag ++ sexTag ++ areaTag

      (userId, (userIds, tags))
    })
```

###### 2.15.5.2.2.2：标签抽取实现

###### 1）：广告位类型 打标签返回Map类型

```scala
package tag

import `trait`.MakeTag
import org.apache.spark.sql.Row

/**
  * 广告类型标签
  */
object AdTypeTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {
    var result = Map[String,Double]()
    //1、获取数据
    val row = args.head.asInstanceOf[Row]
    //2、生成标签
    val adspacetypename = row.getAs[String]("adspacetypename")

    result +=(s"AT_${adspacetypename}"->1.0)
    //3、数据返回
    result
  }
}

```

###### 2）： APP名称 打标签返回Map类型

```scala
package tag

import `trait`.MakeTag
import org.apache.spark.broadcast.Broadcast
import org.apache.spark.sql.Row

/**
  * 生成app标签
  */
object AppTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {

    var result = Map[String,Double]()
    //1、获取数据
    //row对象
    val row = args.head.asInstanceOf[Row]
    //字典文件夹
    val bc = args.last.asInstanceOf[Broadcast[Map[String, String]]]
    //2、判断如果name为空，从字典文件中获取name
    var appName:String = row.getAs[String]("appname")
    val appId = row.getAs[String]("appid")

    appName = Option(appName) match {
      case Some(appName) =>
        appName
      case None =>
        bc.value(appId)
    }
    //美图  都挺好
    //app:美图、王者荣耀    kw:都挺好、吃鸡
    //3、打标签
    result+=(s"APP_${appName}"->1.0)
    //4、数据返回

    result
  }
}

```

###### 3）：渠道 打标签返回Map类型

```scala
package tag

import `trait`.MakeTag
import org.apache.spark.sql.Row

/**
  * 生成渠道标签
  */
object ChannelTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {

    var result = Map[String,Double]()
    //1、取出数据
    val row = args.head.asInstanceOf[Row]
    //2、生成标签
    val channel = row.getAs[String]("channelid")

    result +=(s"CN_${channel}"->1.0)
    //3、数据返回

    result
  }
}

```

###### 4）：设备：操作系统|联网方式|运营商 打标签返回Map类型

```scala
package tag

import `trait`.MakeTag
import org.apache.spark.broadcast.Broadcast
import org.apache.spark.sql.Row

/**
  * 生成设备标签
  */
object DeviceTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {

    var result= Map[String,Double]()
    //1、取出数据
    val row = args.head.asInstanceOf[Row]

    val bc = args.last.asInstanceOf[Broadcast[Map[String,String]]].value
    //2、将字段值转成字典值
    //设备型号、设备类型01、设备类型02、运营商、联网方式
    //设备型号
    val device = row.getAs[String]("device")
    //设备类型
    val client = row.getAs[Long]("client")

    val devicetype = row.getAs[Long]("devicetype")
    //运营商
    val ispname = row.getAs[String]("ispname")
    //联网方式
    val networkmannername = row.getAs[String]("networkmannername")
    //设备类型字典值
    val clientBc = bc(client.toString)
    //运营商字典值
    val ipsnameBc = bc(ispname)
    //联网方式字典值
    val networkmannernameBc = bc(networkmannername)
    //3、生成标签
    result += (s"CB_${clientBc}"->1.0)
    result += (s"ISP_${ipsnameBc}"->1.0)
    result += (s"NM_${networkmannernameBc}"->1.0)
    result += (s"DT_${devicetype.toString}"->1.0)
    result += (s"DEVICE_${device}"->1.0)
    //4、返回数据
    result
  }
}

```

###### 5）：关键词 打标签返回Map类型

```scala
package tag

import `trait`.MakeTag
import org.apache.spark.sql.Row

/**
  * 生成关键字标签
  */
object KeywordTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {

    var result = Map[String,Double]()
    //1、获取数据
    val row = args.head.asInstanceOf[Row]
    //2、生成标签

    val keywords = row.getAs[String]("keywords")

    keywords.split(",").foreach(kw=>{
      result +=(s"KW_${kw}"->1.0)
    })
    //3、数据返回
    result
  }
}

```

###### 6）：地域标签 打标签返回Map类型

```scala
package tag

import `trait`.MakeTag
import org.apache.spark.sql.Row

/**
  * 生成地域标签
  */
object RegionTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {

    var result = Map[String,Double]()
    //1、获取数据
    val row = args.head.asInstanceOf[Row]
    //2、生成标签
    //省
    val proviceName = row.getAs[String]("proviceName")
    //城市
    val cityName = row.getAs[String]("city")

    result +=(s"PN_${proviceName}"->1.0)
    result +=(s"CTN_${cityName}"->1.0)
    //3、返回数据
    result
  }
}

```

###### 7）：获取性别标签

```scala
package tag

import `trait`.MakeTag
import org.apache.spark.sql.Row

object SexTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {

    var result = Map[String,Double]()
    //1、取出数据
    val row = args.head.asInstanceOf[Row]
    //2、生成标签
    val sex = row.getAs[String]("sex")

    result+=(s"SEX_${sex}"->1.0)
    //3、数据返回

    result
  }
}

```

###### 8）：获取年龄标签

```scala
package tag

import `trait`.MakeTag
import org.apache.spark.sql.Row

/**
  * 生成年龄标签
  */
object AgeTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {

    var result = Map[String,Double]()

    //1、取出数据
    val row = args.head.asInstanceOf[Row]

    //2、生成标签
    val age = row.getAs[String]("age")

    result +=(s"AGE_${age}"->1.0)
    //3、数据返回
    result
  }
}

```

###### 9）：用户所有识别码

```scala
//10、用户所有标识
val userIds = getAllUserIds(row)
//用户唯一标识
val userId = userIds.head
```

```scala
  /**
    * 获取用户所有标识
    * @param row
    * @return
    */
  def getAllUserIds(row:Row):List[String]={

    var result = List[String]()

    val imei = row.getAs[String]("imei")

    val mac = row.getAs[String]("mac")

    val idfa = row.getAs[String]("idfa")

    val openudid = row.getAs[String]("openudid")

    val androidid = row.getAs[String]("androidid")

    if(StringUtils.isNotBlank(imei)){
      result = result.:+(imei)
    }

    if(StringUtils.isNotBlank(mac)){
      result = result.:+(mac)
    }

    if(StringUtils.isNotBlank(idfa)){
      result = result.:+(idfa)
    }

    if(StringUtils.isNotBlank(openudid)){
      result = result.:+(openudid)
    }

    if(StringUtils.isNotBlank(androidid)){
      result = result.:+(androidid)
    }
    result
  }
```

###### 10）：加入商圈标签

```scala
package tag

import `trait`.MakeTag
import ch.hsr.geohash.GeoHash
import org.apache.commons.lang3.StringUtils
import org.apache.spark.sql.Row
import utils.JdbcUtils

/**
  * 生成商圈标签
  */
object BusinessAreaTag extends MakeTag{
  /**
    * 生成标签，后续不同标签有不同逻辑
    *
    * @param args
    * @return
    */
  override def make(args: Any*): Map[String, Double] = {

    var result = Map[String,Double]()
    //1、取出商圈信息
    val row = args.head.asInstanceOf[Row]
    //商圈信息
    val areas = row.getAs[String]("areas")
    //3、生成标签  商圈,商圈,商圈..
    if(StringUtils.isNotBlank(areas)){

      areas.split(",").foreach(area=>result+=(s"BA_${area}"->1.0))
    }
    //4、数据返回
    result
  }

}


```



