# 消息总线与驱动

Q1：SpringCloud Bus 消息总线的作用？
SpringCloud Bus消息总线属于中间件，其实是通过消息中间件的主题模式，使用广播消息的机制被所有在注册中心上注册的微服务实例进行监听和消费，以广播的形式将消息推送给所有服务
SpringCloud Bus将分布式的节点用轻量级的消息代理连接起来，配合SpringCloud Config实现微服务应用配置信息的动态更新

Q2：SpringCloud config如何实现刷新配置文件
刷新配置文件有两种方式，首先在每个微服务上都需要使用@RefreshScope
1.手动刷新，每次在git或者svn上修改配置文件后，必须手动调用接口`http://ip:port/actuator/refresh`通知刷新每一个微服务。当微服务数量很多的时候，因为每个都要手动调接口刷新，这样代价很大
2.消息总线bus通知整个微服务刷新，只要调用任意一个微服务的刷新接口`http://ip:port/actuator/bus-refresh`接口，然后bus集成的RabbitMQ（或者Kafka）就会利用发布订阅模式（广播机制）通知到每一个服务，这样整个微服务就全部刷新了

Q3：SpringCloudStream消息驱动的作用
SpringCloud Stream消息驱动整合了常用的MQ框架（目前支持RabbitMQ和Kafka）使得开发人员不需要具体了解MQ的底层实现，只需要关注核心逻辑业务编码就可以了
通过把RabbitMQ和Kafka封装成同一个API，开发人员只需要对接这个API即可
SpringCloud Stream只整合和常用的功能，一些不常用的功能并没有整合，如果需要用到这些功能，还是只能去使用原生的MQ
任务⑧：分布式事务解决方案0085-0087
Q4：分布式事务难题产生的背景
传统项目大部分情况下不会产生分布式事务问题，但是如果在项目中使用了多数据源，就会产生分布式事务问题
微服务环境下会根据不同的业务拆分成不同的服务，每个服务都有自己独立的数据库并且互不影响，相互通讯使用RPC远程调用技术，这时候如果一个业务逻辑之间需要横跨两个服务，就会产生分布式事务问题

Q5：谈谈你在项目中那里遇到分布式事务问题？
传统项目在使用多数据源的时候，如果一个业务逻辑之间需要在两个数据源之间切换，就会出现分布式事务问题

Q6：理解Base与CAP理论、最终一致性概念
CAP理论是指Consistency（一致性）、Availability（可用性）和Partition tolerance（分区容忍性）这三个要素最多只能实现两点，不可能三者兼顾，所以在分布式架构设计时要进行取舍；一般分区容忍性是基本要求，并且对于大多数web应用，并不需要强调一致性，所以一般都是牺牲一致性换取高可用性
BASE理论是指Basically Available（基本可以）、Soft-state（软状态、柔性事物）和Eventual Consistency（最终一致性）是基于CAP演化而来，核心思想是即使无法做到强一致性（刚性事务ACID），也可以根据自身特点、采用适当的方式来使系统达到最终一致性
最终一致性是指系统中所有的数据副本经过一定时间后，最终能达到一致的状态、不需要实时保证系统数据的强一致性。最终一致性是弱一致性的一种特殊情况。BASE理论面向的是大型高可用可拓展的分布式系统，通过牺牲强一致性来获得可用性。

Q7：柔性事务与刚性事务区别
刚性事务是指满足ACID理论的事务
柔性事务满足BASE理论（基本可用、最终一致性），其中主要有两阶段型、补偿型、异步确保型、最大努力通知型

Q8：什么是2PC两阶段提交协议
两段提交协议中，事务提交需要经过两个阶段：
第一阶段协调者会向参与者发送指令，如果参与者收到指令后会执行业务逻辑并且锁定资源、然后把该业务逻辑是否执行成功返回给协调者
第二阶段中如果参与者都返回执行成功，协调者会发送提交事务通知，如果有任何一方执行失败，协调者会终止提交，参与者会取消已经变更的事务，释放锁定的资源。
缺点就是如果协调者经过第一阶段后宕机，参与者没有协调者指挥的话，会一直阻塞、锁定资源

Q9：分布式事务有那些解决方案
1.传统模式使用Jta+ Atomikos
2.支付宝支付的回调通知补偿模型
3.使用阿里的TCC补偿框架
4.使用可靠消息模式（如利用RabbitMQ采用最终一致性原理）
5.使用LCN框架解决分布式事务问题
6.使用阿里的GTS框架解决分布式事务问题

Q10：你们项目中如何解决分布式事务
传统项目直接采用Jta+Atomikos的方式
微服务可以使用LCN框架

Q11：LCN解决分布式事务原理
1.LCN客户端（发起方和参与方）都必须要注册到事务协调者TxManager中，并且建立长连接
2.发起方调用参与方接口之前，会向事务协调者TM申请创建一个事务分组ID
3.发起方调用参与方时会在请求头中存放该事物的分组ID给参与方
4.如果参与方获取到请求头中有对应的事务分组ID，参与方的业务逻辑代码执行完毕之后JDBC连接会进行假关闭，不提交该事务（TxClient代理连接池实现了javax.sql.DataSource接口，并且重写了close方法，参与方的本地事务模块在提交关闭以后TxClient连接池将执行假关闭操作，等待TM协调完成事务后再关闭连接）
5.发起方在执行成功后（事务成功提交）使用对应的事务分组ID通知协调者TM，然后TM再根据对应事务分组ID通知所有参与方提交事务。注意，这里有一个超时时间，超时后参与方会默认回滚事务，不管发起方的事务是否执行成功

Q12：分布式事务解决方案有那些
同Q9
