# ZooKeeper

Q1：什么是ZooKeeper
Zookeeper是一个分布式协调工具，是java语言编写的开源框架

Q2：ZooKeeper存储结构与特性
Zookeeper以节点（Node）的方式进行存储，类似XML的树状结构（目录结构）
Node节点有节点路径和节点value两个属性
节点路径相同层级不能重复
节点类型有两种，临时节点和持久节点（保存在持久化设备-硬盘上）
每个节点都有事件通知（Watcher），对该节点发生删除、修改、添加都会有事件通知，类似消息中间件的功能

Q3：ZooKeeper中临时节点与持久节点区别
持久节点：创建的节点会永久持久化在硬盘上
临时节点：当前节点和会话连接生命周期相同，如果连接断开，那么该节点也会删除（利用这一特性可以作为微服务中的注册中心，同时分布式锁的底层就是用的临时节点）

Q4：ZooKeeper应用场景
可作为命名服务（注册中心），可以作为Dubbo、SpringCloud的注册中心
可作为分布式配置中心，类似的还有SpringCloud Config、阿波罗，动态管理配置文件信息
可作为消息中间件，实现事件通知（类似发布订阅的功能）、集群管理
基于Zookeeper实现分布式锁（利用临时节点）
Zookeeper可以实现选举机制（类似Redis的哨兵机制）
实现本地动态负载均衡
作为注册中心时一般都采用集群保证高可用性

Q5：Dubbo本地动态负载均衡原理
基于Zookeeper实现本地动态负载均衡，Dubbo使用Zookeeper作为注册中心，从ZK上获取注册列表获取服务器集群信息后通过本地轮询机制实现本地动态负载均衡

Q6：什么场景下会导致ZooKeeper发生延迟通知
强行关闭ZK连接而不是通过close方法

Q7：分布式锁有那些实现方案
数据库实现分布式锁（不推荐，效率低）
基于Redis实现分布式锁redission（使用setnx非常麻烦，还需要考虑死锁和释放锁的问题）
基于Zookeeper实现分布式锁（推荐），使用临时节点释放锁，效率高、实现简单、失效时间容易控制
SpringCloud内置实现全局所（很少见）

Q8：ZooKeeper实现分布式锁的原理
多个jvm同时在zk上创建一个相同节点路径的节点。因为节点时唯一的，那么如果有多个客户端同时创建，最终成功的只能有一个，其他的都会进行阻塞等待，从而实现加锁。
当前jvm已经执行完毕时就会关闭zk会话，临时节点被删除，从而实现释放锁，这时其他jvm就会使用Watcher事件通知获取到这一信息重新进入获取锁的请求。

Q9：ZooKeeper实现分布式锁与Redis实现分布式锁区别
使用redis实现分布式锁，锁的失效时间难控制、容易产生死锁、非阻塞式、不可重入
使用zookeeper实现分布式锁，实现相对简单、可靠性强、使用临时节点，失效时间容易控制

Q10：使用Zookeeper实现服务Master选举原理
多个服务在启动时会在Zookeeper上创建相同的临时节点，那个能创建成功就是Master（保证唯一性）。如果主服务宕机后，会话连接也会失效，其他服务器又开始重新选举（通过事件监听，监听到节点被删除后，重新进行选举）

Q11：ZooKeeper集群选举原理
Zookeeper的集群选举中有两种角色：leader和learner（又包含follower和observer）。只能保证有一个leader，底层采用Zab协议（原子广播）提供两种模式：恢复模式，当主一旦宕机，再从多个follower中重新选择一个作为leader；广播模式，保证每个Server之间的数据同步问题。

Q12：分布式Session一致性解决方案有那些
直接使用cookie代替Session（不安全）
使用nginx反向代理的ip绑定，同一个ip只能在同一个服务器上访问（也不推荐，相当于没有集群）
使用数据库（效率不高、不推荐）
使用Tomcat内置的对Session的同步（同步存在延迟，不推荐）
使用Spring-Session框架，相当于把Session缓存到Redis中
使用token代替session，token最终存放到redis中，实现分布式共享

Q13：网站跨域问题有遇到过吗？

有，一般前后端分离的项目当前端项目使用ajax进行通讯时，当ajax访问的域名（或者IP）、端口号与本身项目不同时，默认情况下浏览器会有安全机制，这个机制就是跨域问题，会造成无法获取到返回结果（但实际还是可以访问的，请求状态码为200，但无法获取到结果）

Q14：网站跨域你是如何解决的？
一般通过nginx进行反向代理，遇到小项目没用到nginx的，可以通过设置响应头允许跨域的方式：response.setHeader(“Access-Control-Allow-Origin”,”*”);

Q15：jsonp解决跨域有那些缺点
不支持POST请求，只支持GET，同时在服务端还需要改写返回类型，需要以流的形式而不是json格式进行返回。
Q16：谈谈网站跨域解决方案
使用jsonp解决跨域问题（不推荐，因为只能支持GET请求，不支持POST请求）
设置响应头允许跨域（小公司、小项目可以使用，能快速解决问题）
使用httpClient进行转发（会发送两次请求，效率低，不推荐）
使用nginx搭建API网关（推荐），保证了域名和端口都一致，以项目进行区分反向代理到真实服务器地址
使用Zuul微服务API接口网关（SpringCloud中）
